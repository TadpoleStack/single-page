<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas画质控报告-图形跟随坐标轴</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      html,
      body,
      #app {
        width: 100%;
        height: 100%;
      }
      #box {
        margin: 100px;
        width: 40%;
        height: 50%;
        border: 1px solid rgba(0, 0, 0, 0.3);
      }
    </style>
    <link
      rel="stylesheet"
      href="https://unpkg.com/element-plus/lib/theme-chalk/index.css"
    />
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/vuex/4.0.0-rc.1/vuex.global.js"></script>
    <script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
<script id="template" type="x-template">
  <div id="box"></div>
</script>
<script>
  const {
    createApp,
    defineComponent,
    reactive,
    toRefs,
    onMounted,
    computed,
  } = Vue;
  const App = defineComponent({
    name: "App",
    template: "#template",
    setup() {
      const state = reactive({});
      const canvasStart = (config) => {
        //获取DOM对象属性
        const getStyle = (obj, att) =>
          obj.currentStyle
            ? obj.currentStyle[att]
            : window.getComputedStyle(obj, false)[att];
        let box = document.querySelector(config.selector);
        let canvas = document.createElement("canvas");
        box.appendChild(canvas);
        let minX = 0; //X轴最小值
        let minY = 0; //Y轴最小值
        let maxX = 0; //X轴最大值
        let maxY = 0; //Y轴最大值
        let grid = { left: 25, right: 25, top: 25, bottom: 25 }; //边距
        let cellX = 1; //像素比
        let cellY = 1; //像素比
        let axis = {}; //坐标轴
        let width = 0; //画布宽
        let height = 0; //画布高
        let ctx = canvas.getContext("2d");
        let lineList = []; //线的数据三维数组
        let axisX = 0; //X轴起始点
        let axisY = 0; //Y轴起始点
        //原点即： [axisX*cellX+grid.left,axisY*cellY+grid.top]
        //初始化
        const init = () => {
          //设置canvas宽高与box相等
          width = Number(getStyle(box, "width").replace("px", ""));
          height = Number(getStyle(box, "height").replace("px", ""));
          canvas.width = width;
          canvas.height = height;
          lineList = config.data;
          axis = config.axis;
          if(config.grid)grid = config.grid
          minX = 0;
          minY = 0;
          maxX = 0;
          maxY = 0;
        };
        //获取数据点X对应坐标中的X 原点坐标即 X 为0
        const coordX = (X) => {
          return (axisX + X) * cellX + grid.left;
        };
        //获取数据点Y对应坐标中的Y 原点坐标即 Y 为0
        const coordY = (Y) => {
          return height - (axisY + Y) * cellY - grid.bottom;
        };
        //计算
        const computed = () => {
          //计算坐标轴的极值
          for (let i = 0, Len = axis.x.length; i < Len; i++) {
            let item = axis.x[i];
            if (item > maxX) maxX = item;
            if (item < minX) minX = item;
          }
          for (let i = 0, Len = axis.y.length; i < Len; i++) {
            let item = axis.y[i];
            if (item > maxY) maxY = item;
            if (item < minY) minY = item;
          }
          //计算像素比
          cellX = (width - grid.left - grid.right) / (maxX - minX);
          cellY = (height - grid.top - grid.bottom) / (maxY - minY);
          //坐标轴
          axisX = minX < 0 ? -minX : 0;
          axisY = minY < 0 ? -minY : 0;
        };
        //画坐标轴
        const drawAxis = () => {
          ctx.beginPath();
          //X轴
          ctx.moveTo(0 + grid.left, coordY(0) + 0.5);
          ctx.lineTo(width - grid.right, coordY(0) + 0.5);
          //Y轴
          ctx.moveTo(coordX(0) + 0.5, 0 + grid.top);
          ctx.lineTo(coordX(0) + 0.5, height - grid.bottom);
          ctx.stroke();
        };
        //画刻度
        const drawScale = () => {
          ctx.beginPath();
          //x轴
          for (let i = 0, Len = axis.x.length; i < Len; i++) {
            let item = axis.x[i];
            ctx.moveTo(coordX(item) + 0.5, coordY(0));
            ctx.lineTo(coordX(item) + 0.5, coordY(0) + 6);
            ctx.textBaseline = "top";
            ctx.textAlign = "center";
            ctx.fillText(item, coordX(item), coordY(0) + 8);
          }
          //y轴
          for (let i = 0, Len = axis.y.length; i < Len; i++) {
            let item = axis.y[i];
            ctx.moveTo(coordX(0), coordY(item) - 0.5);
            ctx.lineTo(coordX(0) - 6, coordY(item) - 0.5);
            ctx.textBaseline = "middle";
            ctx.textAlign = "right";
            ctx.fillText(item, coordX(0) - 8, coordY(item));
          }
          ctx.stroke();
        };
        //画线
        const drawLine = () => {
          ctx.beginPath();
          ctx.strokeStyle = "rgb(187,206,225)";
          for (let i = 0, lineLen = lineList.length; i < lineLen; i++) {
            let lineItem = lineList[i];
            for (let k = 0, pointerLen = lineItem.length; k < pointerLen; k++) {
              let pointerItem = lineItem[k];
              if (k == 0) {
                ctx.moveTo(coordX(pointerItem[0]), coordY(pointerItem[1]));
              } else {
                ctx.lineTo(coordX(pointerItem[0]), coordY(pointerItem[1]));
              }
            }
          }
          ctx.stroke();
          
            /*
            * [-5, -2],
                [-3, 8],
                [0, 0],
                B(t) = Math.pow((1-t),2)*p0+2*t*(1-t)*p1+Math.pow(t,2)*p2
                p1 = (Math.pow((1-t),2)*p0+Math.pow(t,2)*p2 - B)/-2*t*(1-t)
            */
           const getPointer = (t,p0,p1,p2)=>{
            return Math.pow((1-t),2)*p0+2*t*(1-t)*p1+Math.pow(t,2)*p2
           }
           const getP1 = (t,p0,B,p2)=>{
               return (Math.pow((1-t),2)*p0+Math.pow(t,2)*p2 - B)/-2*t*(1-t)
           }
            ctx.beginPath()
            ctx.moveTo(coordX(-5),coordY(-2))
            ctx.quadraticCurveTo(coordX(-3),coordY(8),coordX(0),coordY(0))
            ctx.stroke()
            ctx.beginPath()
            ctx.fillStyle='red'
            ctx.arc(getPointer(0.5,coordX(-5),coordX(-3),coordX(0)),getPointer(0.5,coordY(-2),coordY(8),coordY(0)),2,0,Math.PI*2,true)
            ctx.fill()
        };
        init();
        computed();
        drawAxis();
        drawScale();
        drawLine();

        canvas.addEventListener("mousemove", (e) => {
          let X = e.clientX - canvas.offsetLeft;
          let Y = e.clientY - canvas.offsetTop;
          ctx.clearRect(0, 0, width, height);
          ctx.setLineDash([]);
          ctx.lineWidth = 1;
          drawAxis();
          drawScale();
          drawLine();
          ctx.beginPath();
          ctx.strokeStyle = "rgb(0,0,0)";
          ctx.setLineDash([1]);
          ctx.lineWidth = 0.5;
          ctx.moveTo(0, Y - 0.5);
          ctx.lineTo(width - 0.5, Y - 0.5);
          ctx.moveTo(X - 0.5, 0);
          ctx.lineTo(X - 0.5, height - 0.5);
          ctx.stroke();
        });
        canvas.addEventListener("mouseout", (e) => {
          ctx.clearRect(0, 0, width, height);
          ctx.setLineDash([]);
          ctx.lineWidth = 1;
          drawAxis();
          drawScale();
          drawLine();
        });
        return {
          //更新
          update: function (updateConfig) {
            config = Object.assign(config, updateConfig);
            ctx.clearRect(0, 0, width, height);
            init();
            computed();
            drawAxis();
            drawScale();
            drawLine();
          },
          //重置大小
          resize: function () {
            ctx.clearRect(0, 0, width, height);
            init();
            computed();
            drawAxis();
            drawScale();
            drawLine();
          },
          ctx: ctx,
        };
      };
      onMounted(() => {
        let data = [];
        const { resize, update, ctx } = canvasStart({
          selector: "#box",
          data: [
              [
                [-5, -2],
                [-3, 8],
                [0, 0],
                [1, 6],
                [4, -1],
              ],
         ],
            axis: {
              y: [-2, 12],
              x: [-5, 5],
            },
          grid: {
            left: 30,
            top:30,
            right:30,
            bottom:30
          }
        });
      });
      return {
        ...toRefs(state)
      };
    },
  });
  const app = createApp(App);
  app.use(ElementPlus).mount("#app");
</script>
