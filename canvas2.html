<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas画质控报告2</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      html,
      body,
      #app {
        width: 100%;
        height: 100%;
      }
      #box {
        margin: 100px;
        width: 370px;
        height: 440px;
        border: 1px solid rgb(0, 0, 0, 0.3);
      }
    </style>
    <link
      rel="stylesheet"
      href="https://unpkg.com/element-plus/lib/theme-chalk/index.css"
    />
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/vuex/4.0.0-rc.1/vuex.global.js"></script>
    <script src="https://unpkg.com/element-plus/lib/index.full.js"></script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
<script id="template" type="x-template">
  <div id="box"></div>
</script>
<script>
  const {
    createApp,
    defineComponent,
    reactive,
    toRefs,
    onMounted,
    computed,
  } = Vue;
  const App = defineComponent({
    name: "App",
    template: "#template",
    setup() {
      const state = reactive({});

      const canvasStart = (config) => {
        //获取DOM对象属性
        const getStyle = (obj, att) =>
          obj.currentStyle
            ? obj.currentStyle[att]
            : window.getComputedStyle(obj, false)[att];
        let box = document.querySelector(config.selector);
        let canvas = document.createElement("canvas");
        box.appendChild(canvas);
        let ctx = canvas.getContext("2d");
        let width = 0;
        let height = 0;
        let itemHeight = 10;
        let interval = 6;
        let data = [];
        let errLine = [];
        let heightPointer = [];
        let startX = 25;
        //初始化
        const init = () => {
          height = 0;
          heightPointer = [];
          config.interval && (interval = config.interval);
          config.itemHeight && (itemHeight = config.itemHeight);
          width = Number(getStyle(box, "width").replace("px", ""));
          canvas.width = width;
          data = config.data;
          errLine = config.errLine;
        };
        //计算
        const computed = () => {
          for (let i = 0, dataLen = data.length; i < dataLen; i++) {
            let moudelItem = data[i];
            height += 20;
            for (let k = 0, itemLen = moudelItem.length; k < itemLen; k++) {
              let item = moudelItem[k];
              height += itemHeight + interval;
              heightPointer.push(height);
            }
            height += 20;
          }
          height += 20;
          canvas.height = height;
          box.style.height = height + "px";
        };
        //画图
        const draw = () => {
          let count = 0;
          for (let i = 0, dataLen = data.length; i < dataLen; i++) {
            let moudelItem = data[i];
            ctx.textBaseline = "bottom";
            ctx.fillText(config.itemText[i]?config.itemText[i]:'', 0, heightPointer[count] - 10);
            for (let k = 0, itemLen = moudelItem.length; k < itemLen; k++) {
              let item = moudelItem[k];
              ctx.fillStyle = "rgb(187,206,225)";
              ctx.fillRect(startX, heightPointer[count], item, itemHeight);
              ctx.fillStyle = "rgb(0,0,0)";
              ctx.textBaseline = "top";
              ctx.textAlign = "left";
              ctx.fillText(item / 100, 0, heightPointer[count]);
              count++;
            }
          }
        };
        //画误差线
        const drawLine = () => {
          ctx.beginPath();
          ctx.setLineDash([1]);
          for (let i = 0, errLineLen = errLine.length; i < errLineLen; i++) {
            let errItem = errLine[i];
            ctx.moveTo(
              startX + errItem.value - 0.5,
              heightPointer[0] - interval
            );
            ctx.lineTo(
              startX + errItem.value - 0.5,
              heightPointer[heightPointer.length - 1] + itemHeight + interval
            );
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            ctx.fillText(
              errItem.text,
              startX + errItem.value,
              errItem.place === "top"
                ? heightPointer[0] - interval - 5
                : heightPointer[heightPointer.length - 1] +
                    itemHeight +
                    interval +
                    5
            );
          }
          ctx.stroke();
        };

        init();
        computed();
        draw();
        drawLine();
        return {
          //更新
          update: function (updateConfig) {
            config = Object.assign(config, updateConfig);
            ctx.clearRect(0, 0, width, height);
            init();
            computed();
            draw();
            drawLine();
          },
          //重置大小
          resize: function () {
            ctx.clearRect(0, 0, width, height);
          },
          ctx: ctx,
        };
      };
      onMounted(() => {
        let data = [
          [307, 303, 307, 302, 304, 303, 298, 289, 297],
          [309, 309, 311, 304, 306, 306, 307, 297, 304],
        ];
        //data 为二维数组
        const { update, resize, ctx } = canvasStart({
          selector: "#box",
          data: data,
          itemText: ["呼气", "吸气"],
          interval: 6, //间隔
          itemHeight: 10, //柱状高度
          errLine: [
            //误差线
            { value: 300, text: "3.00L", place: "top" },
            { value: 300 + 300 * 0.03, text: "3%", place: "bottom" },
            { value: 300 + 300 * -0.03, text: "-3%", place: "bottom" },
            { value: 300 + 300 * 0.1, text: "10%", place: "top" },
            { value: 300 + 300 * -0.1, text: "-10%", place: "top" },
          ],
        });
      });
      return {
        ...toRefs(state),
      };
    },
  });
  const app = createApp(App);
  app.use(ElementPlus).mount("#app");
</script>
